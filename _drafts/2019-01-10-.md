---
ID: 92
post_title: ""
author: adnaan
post_excerpt: ""
layout: post
permalink: http://adnaan.badr.in/?p=92
published: false
---
# On Mocking

We often need to simulate or mimic an object to create a determininstic, fast and network independent object. Such a simulated object would be quite useful in testing. This is also known as mocking.

Let's look at a few approaches to mock in Go.

Since database is one of the components which is often mocked, let's look at a stubbed out example for it.

## Example

So if you have a type `User`.

```go
type User struct {
    ID string
    Name string
}
```

and a type `Storage` which represents a database.

```go
type Storage struct{
    db *sql.DB
}

func (s *Storage) CreateUser(user User)error{
    // db.Exec(...)
}
```

In the above psuedo-code there are two ways to mock the behaviour of `Storage` without using a real db connection.

The first way is to mock the `db` object itself. The second way is to mock the `CreateUser` method.

Driver-level mocking is not trivial but it's possible to find packages out there: [DATA-DOG/go-sqlmock](https://github.com/DATA-DOG/go-sqlmock).

Let's see the approaches to mock out the methods.

## How to mock

### 1. Using Interfaces

To mock out the `Storage` type, we can declare an interface to have a real and mock implementation.

So instead of creating a `type Storage struct`, we create a `type Storage interface`. 

```go
type Storage interface {
    CreateUser(user User)error
}
```

Implement a real storage for the interface `Storage`.

```go

func NewStorage(db *sql.DB)Storage{
    return &defaultStorage{db:db}
}

type defaultStorage truct{
    db *sql.DB
}

func (s *defaultStorage) CreateUser(user User)error{
    // db.Exec(...)
}
```

and a mock storage.

```go
func NewMockStorage(db *sql.DB)Storage{
    return &mockStorage{db:db}
}

type mockStorage truct{
    db *sql.DB
}

func (s *mockStorage) CreateUser(user User)error{
    // db.Exec(...)
}
```

Alternatively, once could split this into multiple packages to keep the method signatures same and imports more sensible.

```bash
pkg/storage/
    mocksql/
    sql/
    storage.go
```

`sql.go`

```go
func New(db *sql.DB)Storage{
    return &storage{db:db}
}

type storage truct{
    db *sql.DB
}

func (s *storage) CreateUser(user User)error{
    // db.Exec(...)
}
```

`mocksql/sql.go`

```go
func New(db *sql.DB)Storage{
    return &storage{db:db}
}

type storage truct{
    db *sql.DB
}

func (s *storage) CreateUser(user User)error{
    // db.Exec(...)
}
```

`storage.go`

```go
type Storage interface {
    CreateUser(user User)error
}

func NewSQL()Storage{
    return sql.New()
}

func NewMockSQL()Storage{
    return mocksql.New()
}

```

To import.

`user.go`

```go
import "github.com/myuser/mypkg/pkg/storage"

...

storage := storage.NewSQL()

```

`user_test.go`

```go
import "github.com/myuser/mypkg/pkg/storage"

...

storage := storage.NewMockSQL()

```

One could imagine that if the `Storage` interface has tens of methods or there are several interfaces like it, it could get quite cumbersome to write out the mock implementations for it. Fortunately there is tooling to help out.

#### Generating Mocks

##### 1. Use an editor plugin

In vscode open the command paletter(cmd+shift+p), move cursor on the target stub and run `Go: Generate Interface Stubs`. Most of the editors supporting Go have this feature integrated.

##### 2. Use a cli or package

[testify/mock](https://godoc.org/github.com/stretchr/testify/mock)
[golang/mock](https://godoc.org/github.com/golang/mock)

### 2. Using Functions

While using interfaces to mock out behaviour is quite alright, it might look too permanent for some projects. Also, one could rather want an approach where the mocking code is completely contained within a test function. There could be two approaches here:

#### 1. Custom Function Types

In this approach you design the `Storage` object to have custom function types.

```go

type CreateUserFunc func(db *sql.DB, user User) error

type Storage struct {
    CreateUserFunc CreateUserFunc
}


```

and use a mock in test code

```go
...

mockStorage := &Storage{
    CreateUserFunc: func(db *sql.DB, user User)error{
        ...
    },
}
```

The problem with this approach is passing around the `db` object in the `CreateUser`funciton signature. Use this approach where there is no such dependency on a `db` like object.

#### 2. Interfaces and Custom Mock Structs

In this approach one still has a `Storage` interface but also implements a mock struct which holds mocked equivalents of the interface methods. This is similar to `1. Custom Function Types` but you don't explicity delcare custom function types in advance. It's also doesn't require for dependencies(`db`) to be passed around.

```go
type Storage interface {
    CreateUser(user User)error
}

type StorageMock struct {
    CreateUserFunc func(user User)error
}

func(s *StorageMock)CreateUser(user User)error{
    return mock.CreateUser(user)
}

// test code

...

mockStorage := &StorageMock{
    CreateUserFunc: func(user User)error{
        return nil
    }
}

```

There is tooling available to generate `StorageMock` via [moq](https://github.com/matryer/moq)

# Conclusion

Depending on a project's complexity, scope and use cases either one of the above mocking approaches could fit. One of the considerations could be other behaviours(apart from mocking) needed for a type. For e.g. the `Storage` type could have muliple database backends implementations like `inmem, postgres, mysql etc.`

Feedback is welcome on [Twitter](https://twitter.com/adnaanx)

Mock well and prosper &#9996;